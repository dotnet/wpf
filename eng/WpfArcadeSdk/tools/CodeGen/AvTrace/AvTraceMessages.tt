<#@ template hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.XDocument" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ output extension=".cs" #>
<#@ parameter type="System.String" name="AvTraceMessageFile" #>
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

// NOTE: This file was generated by $(WpfCodeGenDir)AvTrace\AvTraceMessages.tt.
// Any manual updates to this file will overwritten.

using System;
using System.Diagnostics;

namespace MS.Internal
{
<# 
   string fileName = this.Host.ResolvePath(AvTraceMessageFile);
   XDocument doc = XDocument.Load(fileName);
   foreach (XElement source in doc.Root.Elements("Source"))
   {
		string name = source.Attribute("Name").Value;
        string traceClassName = source.Attribute("TraceNameOverride")?.Value ?? $"Trace{name}";
#>
    static internal partial class <#= traceClassName #>
    {
        static private AvTrace _avTrace = new AvTrace(
                delegate() { return PresentationTraceSources.<#=name#>Source; },
                delegate() { PresentationTraceSources._<#=name#>Source = null; }
                );
<#
		int id = 0;
		foreach (XElement traceDetails in source.Elements("TraceDetails"))
		{
			++id;
			string traceName = traceDetails.Attribute("Name").Value;
#>

		static AvTraceDetails _<#=traceName#>;
<#          if (IsFormattedTraceMessage(traceDetails)) { #>
        static public AvTraceDetails <#= traceName #>(params object[] args)
        {
            if ( _<#=traceName#> == null )
            {
                <# OutputTraceCreation(id, traceDetails); #>
            }
            return new AvTraceFormat(_<#= traceName #>, args);
        }
<#          } else { #>
		static public AvTraceDetails <#= traceName #>
        {
            get
            {
                if ( _<#= traceName #> == null )
                {
                    <# OutputTraceCreation(id, traceDetails); #>
                }

                return _<#= traceName #>;
            }
        }
<#		    } #>
<#		} #>

        /// <summary> Send a single trace output </summary>
        static public void Trace( TraceEventType type, AvTraceDetails traceDetails, params object[] parameters )
        {
            _avTrace.Trace( type, traceDetails.Id, traceDetails.Message, traceDetails.Labels, parameters );
        }

        /// <summary> These help delay allocation of object array </summary>
        static public void Trace( TraceEventType type, AvTraceDetails traceDetails )
        {
            _avTrace.Trace( type, traceDetails.Id, traceDetails.Message, traceDetails.Labels, Array.Empty<object>() );
        }
        static public void Trace( TraceEventType type, AvTraceDetails traceDetails, object p1 )
        {
            _avTrace.Trace( type, traceDetails.Id, traceDetails.Message, traceDetails.Labels, new object[] { p1 } );
        }
        static public void Trace( TraceEventType type, AvTraceDetails traceDetails, object p1, object p2 )
        {
            _avTrace.Trace( type, traceDetails.Id, traceDetails.Message, traceDetails.Labels, new object[] { p1, p2 } );
        }
        static public void Trace( TraceEventType type, AvTraceDetails traceDetails, object p1, object p2, object p3 )
        {
            _avTrace.Trace( type, traceDetails.Id, traceDetails.Message, traceDetails.Labels, new object[] { p1, p2, p3 } );
        }

        /// <summary> Send a singleton "activity" trace (really, this sends the same trace as both a Start and a Stop) </summary>
        static public void TraceActivityItem( AvTraceDetails traceDetails, params Object[] parameters )
        {
            _avTrace.TraceStartStop( traceDetails.Id, traceDetails.Message, traceDetails.Labels, parameters );
        }

        /// <summary> These help delay allocation of object array </summary>
        static public void TraceActivityItem( AvTraceDetails traceDetails )
        {
            _avTrace.TraceStartStop( traceDetails.Id, traceDetails.Message, traceDetails.Labels, Array.Empty<object>() );
        }
        static public void TraceActivityItem( AvTraceDetails traceDetails, object p1 )
        {
            _avTrace.TraceStartStop( traceDetails.Id, traceDetails.Message, traceDetails.Labels, new object[] { p1 } );
        }
        static public void TraceActivityItem( AvTraceDetails traceDetails, object p1, object p2 )
        {
            _avTrace.TraceStartStop( traceDetails.Id, traceDetails.Message, traceDetails.Labels, new object[] { p1, p2 } );
        }
        static public void TraceActivityItem( AvTraceDetails traceDetails, object p1, object p2, object p3 )
        {
            _avTrace.TraceStartStop( traceDetails.Id, traceDetails.Message, traceDetails.Labels, new object[] { p1, p2, p3 } );
        }

        static public bool IsEnabled
        {
            get { return _avTrace != null && _avTrace.IsEnabled; }
        }

        /// <summary> Is there a Tracesource?  (See comment on AvTrace.IsEnabledOverride.) </summary>
        static public bool IsEnabledOverride
        {
            get { return _avTrace.IsEnabledOverride; }
        }

        /// <summary> Re-read the configuration for this trace source </summary>
        static public void Refresh()
        {
            _avTrace.Refresh();
        }
	}
<# } #>
}
<#+
string GetTraceDataString(XElement labels)
{
    // We need to ensure that we have quotes around each of these so that they will be written with them 
    string traceDataString = $"\"{labels.Attribute("Message").Value}\"";
    if (labels.HasElements)
    {
        foreach (XElement param in labels.Elements("Parameters"))
        {
            traceDataString += labels.LastNode != param ? $"\"{param}\", " : $"\"{param}\"";
        }
    }

    return traceDataString;
}
bool IsFormattedTraceMessage(XElement traceDetails)
{
    XElement labels = traceDetails.Element("Labels");
    string traceMessage = labels.Attribute("Message").Value; 
    return traceMessage.Contains("{0}");
}
// Put any Output* methods at the end, as they tend to be a bit messier because they need the special tags.
// For ease of re-use, methods that output text should not make any assumptions about the indentation, and it
// should be the callers responsibility for properly indenting
void OutputTraceCreation(int id, XElement traceDetails)
{
    XElement labels = traceDetails.Element("Labels");
    string dataString = GetTraceDataString(labels);
#>
_<#= traceDetails.Attribute("Name").Value #> = new AvTraceDetails(<#=id#>, new string[] { <#= dataString #> } );
<#+
}
#>
