<Project InitialTargets="EnsureCreateContentFolderRunsBeforeNuspecDependsOn">
  <!-- Dummy 'Pack' target for 'vcxproj' -->
  <Target Name="Pack" Condition="'$(MSBuildProjectExtension)'=='.vcxproj'" />

  <PropertyGroup>
    <!-- Projects can override the name of the 'lib' folder to something else - for e.g., 'tools'-->
    <LibFolder Condition="'$(LibFolder)'==''">lib</LibFolder>
  </PropertyGroup>

  <PropertyGroup>
    <PackageName Condition="'$(CreateArchNeutralPackage)'!='true'">$(PackageRuntimeIdentifierPrefix).$(PackageName)</PackageName>
    <NormalizedPackageName>$(PackageName.Replace('$(PackageRuntimeIdentifierPrefix).',''))</NormalizedPackageName>
    <NuspecPackageId>$(PackageName)</NuspecPackageId>
    <DevelopmentDependency Condition="'$(MsBuildSdkPackage)'=='true'">true</DevelopmentDependency>
    <PackageType Condition="'$(MsBuildSdkPackage)'=='true'">MSBuildSdk</PackageType>
  </PropertyGroup>
  
  <!-- 
   Target: PreparePackageAssets                                                                   
    Copies packages assets for a project to artifacts\packaging\$(Configuration)\$(PackageName)\  
    and prepares it for packaging then Target=Pack is executed                                    
                                                                                                  
   Important properties and items:                                                                
   $(PackageName):  Name of the package                                                           
                    This target will only run for projects that specify $(PackageName)            
                                                                                                  
   @(PackagingContent): Additional content specified by projects                                  
                        Place under content\ in the package by default                            
                        Placement in package can be altered by specifying a SubFolder attribute   
                        <PackagingContent Include="foo.xml" SubFolder="xmls" />  would result in  
                          foo.xml being packaged under content\xmls                               
                          
                          'root' is a special prefix-value for the attribute SubFolder, and it will result
                          in the placement of the file in the root of the package.
  -                       <PackagingContent Include="THIRD-PARTY-NOTICES.TXT"  SubFolder="root"/>   
                          will result in "THIRD-PARTY-NOTICES.TXT" to be placed at the root       
                          of the package.
                          <PackagingContent Include"sdk\*.props" Subfolder="root\sdk" /> will result in
                          relevant *.props files to be placed under the 'sdk' sub-folder in the package.
                          
   @(PackagingAssemblyContent) - 
                        A way to specify which files under $(OutDir) should be packaged. 
                        If this list is set, then we will only carry assemblies specified in this set
                        an no others.
   $(ExcludeRefAssemblies) - true/false to include/exclude ref assemblies from packaging. 
                             default is true.
   $(ExcludePdbs)  - true/false to include/exclude PDB's from packaging
                     default is true
$(PreparePackageAssetsDependsOn):                                                              
                      List of targets that PreparePackageAssets would depend on                   
                      This is an extensibility point                                              
                                                                                                  
   Packaging projects ($(IsPackagingProject) == true) also have $(PackageName) - do not attempt   
   to prepare DLL, EXE, PDB etc. assets for those projects. Only prepare content (PackageAsset)   
   assets for packaging projects                                                                  
   -->
  <Target Name="PreparePackageAssets"
          AfterTargets="Build"
          DependsOnTargets="$(PreparePackageAssetsDependsOn)"
          Condition="'$(PackageName)'!=''">
    
    <!-- Identify $(TargetFrameworkOrRuntimeIdentifier) property -->
    <PropertyGroup>
      <TargetFrameworkOrRuntimeIdentifier Condition="'$(TargetFrameworkOrRuntimeIdentifier)'=='' and '$(TargetFramework)'!=''">$(TargetFramework)</TargetFrameworkOrRuntimeIdentifier>
    </PropertyGroup>
    
    <PropertyGroup Condition="'$(MSBuildProjectExtension)'=='.vcxproj' and '$(TargetFrameworkOrRuntimeIdentifier)'==''">
      <TargetFrameworkOrRuntimeIdentifier Condition="'$(Platform)'=='AnyCPU' or '$(Platform)'=='x86' or '$(Platform)'=='Win32'">win-x86</TargetFrameworkOrRuntimeIdentifier>
      <TargetFrameworkOrRuntimeIdentifier Condition="'$(Platform)'=='x64'">win-x64</TargetFrameworkOrRuntimeIdentifier>
    </PropertyGroup>

    <!--
        Instead of showing an error when $(TargetFrameworkOrRuntimeIdentifier) cannot be identified
        we simply do no further work

        Include all the DLL's, EXE's and PDB's under lib\
        Include all reference assemblies under ref\
        Include all content files under content\

    @(PackageAsset) evaluation should be done after $(PreparePackageAssetsDependsOn) targets have completed running. To ensure
    delayed evaluation, use CreateItem tasks. 
    
    The CreateItem tasks below is equivalent to this: 
    
    <ItemGroup Condition="'$(TargetFrameworkOrRuntimeIdentifier)'!='' and '$(IsPackagingProject)'!='true'">
      <PackageAsset Include="$(OutDir)*.dll" RelativePath="$(ArtifactsPackagingDir)$(PackageName)\lib\$(TargetFrameworkOrRuntimeIdentifier)"/>
      <PackageAsset Include="$(OutDir)*.exe" RelativePath="$(ArtifactsPackagingDir)$(PackageName)\lib\$(TargetFrameworkOrRuntimeIdentifier)"/>
      <PackageAsset Include="$(OutDir)*.pdb" RelativePath="$(ArtifactsPackagingDir)$(PackageName)\lib\$(TargetFrameworkOrRuntimeIdentifier)"/>
      <PackageAsset Include="$(ReferenceAssemblyDir)*.dll" RelativePath="$(ArtifactsPackagingDir)$(PackageName)\ref\$(TargetFrameworkOrRuntimeIdentifier)"/>
    </ItemGroup>
    -->
    <CreateItem Include="$(OutDir)*.dll" 
                AdditionalMetadata="RelativePath=$(ArtifactsPackagingDir)$(NormalizedPackageName)\$(LibFolder)\$(TargetFrameworkOrRuntimeIdentifier)"
                Condition="'$(TargetFrameworkOrRuntimeIdentifier)'!='' and '$(IsPackagingProject)'!='true' and '@(PackagingAssemblyContent)'==''">
      <Output ItemName="PackageAsset" TaskParameter="Include"/>
    </CreateItem>
    <CreateItem Include="$(OutDir)*.exe" 
                AdditionalMetadata="RelativePath=$(ArtifactsPackagingDir)$(NormalizedPackageName)\$(LibFolder)\$(TargetFrameworkOrRuntimeIdentifier)"
                Condition="'$(TargetFrameworkOrRuntimeIdentifier)'!='' and '$(IsPackagingProject)'!='true' and '@(PackagingAssemblyContent)'==''">
      <Output ItemName="PackageAsset" TaskParameter="Include"/>
    </CreateItem>
    <CreateItem Include="$(OutDir)*.pdb" 
                AdditionalMetadata="RelativePath=$(ArtifactsPackagingDir)$(NormalizedPackageName)\$(LibFolder)\$(TargetFrameworkOrRuntimeIdentifier)"
                Condition="'$(TargetFrameworkOrRuntimeIdentifier)'!='' and '$(IsPackagingProject)'!='true' and '$(ExcludePdbs)'!='true' and '@(PackagingAssemblyContent)'==''">
      <Output ItemName="PackageAsset" TaskParameter="Include"/>
    </CreateItem>
    <CreateItem Include="$(ReferenceAssemblyDir)*.dll" 
                AdditionalMetadata="RelativePath=$(ArtifactsPackagingDir)$(NormalizedPackageName)\ref\$(TargetFrameworkOrRuntimeIdentifier)"
                Condition="'$(TargetFrameworkOrRuntimeIdentifier)'!='' and '$(IsPackagingProject)'!='true' and '$(ExcludeRefAssemblies)'!='true'">
      <Output ItemName="PackageAsset" TaskParameter="Include"/>
    </CreateItem>

    <CreateItem Include="$(OutDir)%(PackagingAssemblyContent.Identity)"
            AdditionalMetadata="RelativePath=$(ArtifactsPackagingDir)$(NormalizedPackageName)\$(LibFolder)\$(TargetFrameworkOrRuntimeIdentifier)"
            Condition="'$(TargetFrameworkOrRuntimeIdentifier)'!='' and '$(IsPackagingProject)'!='true' and '@(PackagingAssemblyContent)'!=''">
      <Output ItemName="PackageAsset" TaskParameter="Include"/>
    </CreateItem>
    <!-- 
        $(XlfLanguages) is defined by XliffTasks.
        The conversion of .resx files to .xlf files, and the building of resource assemblies (.resources.dll) and 
        culture-specific satellite assemblies (<culture>\*.resources.dll) are done immediately after Build, as part of 
        CreateSatelliteAssemblies. 
        
        Include satellite assemblies into the package if $(XlfLanguages) is defined. They are included under a relative path
        that is the same as their respective culture identifier (for e.g., 'fr', 'zh-Hans' etc.)
    -->
    <ItemGroup Condition="'$(XlfLanguages)'!=''">
      <PackageAssetCultures Remove="$(PackageAssetCultures)" />
      <PackageAssetCultures Include="$(XlfLanguages)" />
      
      <PackageAsset Include="$(OutDir)%(PackageAssetCultures.Identity)\*.dll" RelativePath="$(ArtifactsPackagingDir)$(NormalizedPackageName)\$(LibFolder)\$(TargetFrameworkOrRuntimeIdentifier)\%(PackageAssetCultures.Identity)" />
    </ItemGroup>
    
    <ItemGroup Condition="'$(TargetFrameworkOrRuntimeIdentifier)'!=''">

      <!-- %(PackagingContent.SubFolder) not StartsWith 'root' -->
      <PackageAsset Condition="'%(PackagingContent.SubFolder)'!='' And !$([System.String]::Copy(&quot;%(PackagingContent.SubFolder)&quot;).StartsWith(&quot;root&quot;))"
              Include="%(PackagingContent.Identity)"
              RelativePath="$(ArtifactsPackagingDir)$(NormalizedPackageName)\content\%(PackagingContent.SubFolder)"/>
      
      <PackageAsset Condition="'%(PackagingContent.SubFolder)'==''" 
                    Include="%(PackagingContent.Identity)" 
                    RelativePath="$(ArtifactsPackagingDir)$(NormalizedPackageName)\content"/>

      <!-- 
          %(PackagingContent.SubFolder) StartsWith 'root' 
            Package content under sub-folder %(PackagingContent.SubFolder).TrimLeft('root')
            
            Keep track of such sub-folders that exist immediately under root in a special ItemGroup - PackagingRootFolderSubFolders
            PackagingRootFolderSubFolders will be used later in CreateContentFolder
            
            Implementation Note:
              SubFolder string looks like this: "root\subfolder1\subfolder2"
                %(SubFolder).SubString(4) ~= "\subfolder1\subfolder2"
                %(SubFolder).SubString(5) ~= "subfolder1\subfolder2"
              
              When concatenating next to $(ArtifactsPackagingDir)$(PackageName), 
                - use %(SubFolder).SubString(4)
                - do not insert a directory separator character (\) between them
                - this has the benefit of working seamlessly when %(SubFolder) == "root"
              
              When SubFolder name must be extracted, 
                - use %(SubFolder).SubString(5)
                - In GenerateNuspec target, we have special-case logic to deal with files directly under the root folder, 
                    so we only need to keep track of sub-folder names.
      -->
      <PackageAsset Condition="$([System.String]::Copy(&quot;%(PackagingContent.SubFolder)&quot;).StartsWith(&quot;root&quot;))"
                    Include="%(PackagingContent.Identity)"
                    RelativePath="$(ArtifactsPackagingDir)$(NormalizedPackageName)$([System.String]::Copy('%(PackagingContent.SubFolder)').SubString(4))"/>

      <PackagingRootFolderSubFolders Condition="$([System.String]::Copy(&quot;%(PackagingContent.SubFolder)&quot;).StartsWith(&quot;root\&quot;))"
                                     Include="$([System.String]::Copy('%(PackagingContent.SubFolder)').SubString(5))">
        <PackageName>$(NormalizedPackageName)</PackageName>
      </PackagingRootFolderSubFolders>
    </ItemGroup>

    <MakeDir Condition="!Exists('%(PackageAsset.RelativePath')" Directories="@(PackageAsset->'%(RelativePath)')" />
    <Copy Condition="(@(PackageAsset->Count()) &gt; 0) And !Exists('%(PackageAsset.RelativePath)\%(PackageAsset.Filename)%(PackageAsset.Extension)')"
          SourceFiles="@(PackageAsset)" 
          DestinationFolder="%(PackageAsset.RelativePath)" />
  </Target>

  <!-- Target:  CreateContentFolder -->
  <!--            Dynamically populates  @(Content) for packaging  -->
   <!--
    This target is only run for projects which specify $(IsPackable) = true               
      By convention, NO WPF projects will specify $(IsPackable) = true                    
      WPF projects will opt into PreparePackageAssets target by specifying $(PackageName) 
      Special packaging-only projects will be used to orchestrate the actual packaging    
                                                                                          
      Also, if an "ArchNeutral" package sets $(IncludeAssembliesInArchNeutralPackage)=true, 
      then it will include 'lib\**\*' files in it anyway. 
      This can be combined with $(PlatformIndependentPackage)=true (which controls the generation
      of runtime.json file) to generate an AnyCPU Sdk package containing ref + lib assemblies alongwith 
      all the props and targets.
                                                                                          
   The following properties are of interest to this target                                                                    
   $(PackageName):  The name of the package                                                                                   
   $(PackageVersion): The package version                                                                                     
   $(Authors): Authors                                                                                                        
   $(PackageDescription): Description                                                                                         
   $(TargetCulture): culture/language of the build. If not specified (or '*'), then $(NeutralLanguage) will be used instead   
   $(RepositoryUrl): Repo Url                                                                                                 
   $(PackageRequireLicenseAcceptance): true/false indicating whether license file acceptance is required                       
   $(MsBuildSdkPackage): true/false indicating whether the nupkg is an MSBuild SDK package. When set to true, the nuspec produces
                         additional content indicating that the package is an Sdk.
                                                                                                                              
   We expect to find $(DefaultPackageLicenseFile) (typically defined as 'LICENSE.TXT' in nupkg\Directory.Build.props) at the  
   root of the packaging content folder . If a $(DefaultPackageLicenseFile) file is not found, we will fallback to            
   $(PackageLicenseExpression) license (typically defined as 'MIT')                     
                                                                                                                              
   When building a nupkg for a bait-and-switch package ($(CreateArchNeutralPackage)==true), the following changes are     
    made:                                                                                                                     
      Package name : A RID is not prefixed onto the package name                                                              
      Files      - : Only ref\ and root-level content files are included
      
  Microsoft.DotNet.Arcade.Sdk\tools\WorkArounds.targets - InitializeStandardNuspecProperties populates $(_CommonMetadataElements)
  with the following metadata information:
    id
    description
    version
    authors
    requireLicenseAcceptance
    license type=
    projectUrl
    copyright
    developmentDependency
    serviceable
    repository type= url= commit=
  In effect, it provides us with all the relevant package metadata we need. We can simply reuse that 
  information here within <metadata>
  -->
  <Target Condition="'$(PackageName)'!='' and '$(IsPackable)'=='true'"
          Name="CreateContentFolder">
    <!-- Use $(TargetCulture) or fallback to $(NeutralLanguage) -->
    <PropertyGroup>
      <BuildCulture Condition="'$(TargetCulture)'!='' and '$(TargetCulture)'!='*'">$(TargetCulture)</BuildCulture>
      <BuildCulture Condition="'$(BuildCulture)'==''">$(NeutralLanguage)</BuildCulture>
    </PropertyGroup>

    <!-- Used to test whether there are any files immediately under $(ArtifactsPackagingDir)$(PackageName)  -->
    <!-- ('@(RootFolderContents)'=='') would be False when there are files available to be packed           -->
    <ItemGroup>
      <RootFolderContents Remove="@(RootFolderContents)" />
      <RootFolderContents Include="$(ArtifactsPackagingDir)$(NormalizedPackageName)\*.*"/>
    </ItemGroup>

    <ItemGroup>
      <Content Include="$(ArtifactsPackagingDir)$(NormalizedPackageName)\$(LibFolder)\**\*.dll"
               Condition="('$(CreateArchNeutralPackage)'!='true' Or '$(IncludeAssembliesInArchNeutralPackage)'== 'true') and Exists('$(ArtifactsPackagingDir)$(NormalizedPackageName)\$(LibFolder)\')" >
        <Pack>true</Pack>
        <PackagePath>$(LibFolder)</PackagePath>
      </Content>
      
      <Content Include="$(ArtifactsPackagingDir)$(NormalizedPackageName)\$(LibFolder)\**\*.exe"
         Condition="('$(CreateArchNeutralPackage)'!='true' Or '$(IncludeAssembliesInArchNeutralPackage)'== 'true') and Exists('$(ArtifactsPackagingDir)$(NormalizedPackageName)\$(LibFolder)\')" >
        <Pack>true</Pack>
        <PackagePath>$(LibFolder)</PackagePath>
      </Content>

      <Content Include="$(ArtifactsPackagingDir)$(NormalizedPackageName)\$(LibFolder)\**\*.pdb"
         Condition="('$(CreateArchNeutralPackage)'!='true' Or '$(IncludeAssembliesInArchNeutralPackage)'== 'true') and Exists('$(ArtifactsPackagingDir)$(NormalizedPackageName)\$(LibFolder)\')" >
        <Pack>true</Pack>
        <PackagePath>$(LibFolder)</PackagePath>
      </Content>

      <Content Include="$(ArtifactsPackagingDir)$(NormalizedPackageName)\ref\**\*.dll"
         Condition="Exists('$(ArtifactsPackagingDir)$(NormalizedPackageName)\ref\')">
        <Pack>true</Pack>
        <PackagePath>ref</PackagePath>
      </Content>

      <Content Include="$(ArtifactsPackagingDir)$(NormalizedPackageName)\content\**\*.*"
               Condition="('$(CreateArchNeutralPackage)'!='true' Or '$(IncludeAssembliesInArchNeutralPackage)'== 'true') and Exists('$(ArtifactsPackagingDir)$(NormalizedPackageName)\content\')" >
        <Pack>true</Pack>
        <PackagePath>content</PackagePath>
      </Content>

      <Content Include="$(ArtifactsPackagingDir)$(NormalizedPackageName)\*.*"
               Exclude="$(ArtifactsPackagingDir)$(NormalizedPackageName)\runtime.json"
              Condition="'$(CreateArchNeutralPackage)'!='true' and '@(RootFolderContents)'!=''" >
        <Pack>true</Pack>
        <PackagePath></PackagePath>
      </Content>

      <Content Include="$(ArtifactsPackagingDir)$(NormalizedPackageName)\*.*"
               Condition="'$(CreateArchNeutralPackage)'=='true' and '@(RootFolderContents)'!=''" >
        <Pack>true</Pack>
        <PackagePath>.</PackagePath>
      </Content>

      <Content Include="$(ArtifactsPackagingDir)$(NormalizedPackageName)\%(PackagingRootFolderSubFolders.Identity)\*.*"
               Condition="'@(PackagingRootFolderSubFolders)'!=''">
        <Pack>true</Pack>
        <PackagePath>%(PackagingRootFolderSubFolders.Identity)</PackagePath>
      </Content>
    </ItemGroup>
    
  </Target>
  
    <!-- 
    We can't reliably insert CreatecontentFolder
    at the head of GenerateNuspecDependsOn during 
    static imports of props/targets, so we do it
    dynamically from within a target
  -->
  <Target Name="EnsureCreateContentFolderRunsBeforeNuspecDependsOn">
    <PropertyGroup>
      <GenerateNuspecDependsOn>
        CreateContentFolder;
        $(GenerateNuspecDependsOn)
      </GenerateNuspecDependsOn>
    </PropertyGroup>
  </Target>

  <!-- Create version.txt containing latest commit ID -->
  <Target Name="GenerateVersionFileWithRepositoryCommit"  
          Condition="'$(IsPackable)'=='true' and '$(CreateArchNeutralPackage)'=='true' and !Exists('$(ArtifactsPackagingDir)$(NormalizedPackageName)\version.txt')" 
          BeforeTargets="CreateContentFolder" 
          Outputs="$(ArtifactsPackagingDir)$(NormalizedPackageName)\version.txt">
    <!-- 
      Workaround 
        Ensure that SourceRevisionId is obtained if it has not already been read in 
        Reuse tasks from Microsoft.Build.Tasks.Git.targets
    --> 
    <Microsoft.Build.Tasks.Git.LocateRepository Directory="$(MSBuildProjectDirectory)" Condition="'$(SourceRevisionId)' == ''" >
      <Output TaskParameter="Id" PropertyName="_GitRepositoryRoot" />
    </Microsoft.Build.Tasks.Git.LocateRepository>
    <Microsoft.Build.Tasks.Git.GetSourceRevisionId Root="$(_GitRepositoryRoot)" Condition="'$(SourceRevisionId)' == ''">
      <Output TaskParameter="RevisionId" PropertyName="SourceRevisionId" />
    </Microsoft.Build.Tasks.Git.GetSourceRevisionId>
    <ItemGroup>
      <RepoCommitVersionFileLines Remove="@(RepoCommitVersionFileLines)" />
      <RepoCommitVersionFileLines Include="$(SourceRevisionId)" />
    </ItemGroup>

    <PropertyGroup>
      <RepoCommitVersionFileDir>$(ArtifactsPackagingDir)$(NormalizedPackageName)\</RepoCommitVersionFileDir>
      <RepoCommitVersionFile>$(RepoCommitVersionFileDir)version.txt</RepoCommitVersionFile>
    </PropertyGroup>

    <MakeDir Condition="!Exists('$(RepoCommitVersionFileDir)')" Directories="$(RepoCommitVersionFileDir)" />
    <WriteLinesToFile Lines="@(RepoCommitVersionFileLines)" File="$(RepoCommitVersionFile)"/>
  </Target>

  <!--  Generate runtime.json for embedding in the arch-neutral package that uses the Bait & Switch technique -->
  <Target Name="GenerateRuntimeJson"
          Condition="'$(IsPackable)'=='true' and '$(CreateArchNeutralPackage)'=='true' and '$(PlatformIndependentPackage)'!='true'"
          BeforeTargets="CreateContentFolder"
          Outputs="$(ArtifactsPackagingDir)$(NormalizedPackageName)\runtime.json">

    <ItemGroup>
      <RuntimeJsonLine Remove="@(RuntimeJsonLine)" />
      <RuntimeJsonLine Include="Json">
        <Text>
          <![CDATA[{
  "runtimes": {
    "win-x64": {
      "$(NormalizedPackageName)": {
        "runtime.win-x64.$(PackageName)": "$(PackageVersion)"
      }
    },
    "win-x86": {
      "$(NormalizedPackageName)": {
        "runtime.win-x86.$(PackageName)": "$(PackageVersion)"
      }
    }
  }
}
        ]]></Text>
      </RuntimeJsonLine>
    </ItemGroup>

    <ItemGroup>
      <RuntimeJson Remove="@(RuntimeJson)" />
      <RuntimeJson Include="@(RuntimeJsonLine->'%(Text)')" />
    </ItemGroup>

    <PropertyGroup>
      <RuntimeJsonFileDir>$(ArtifactsPackagingDir)$(NormalizedPackageName)\</RuntimeJsonFileDir>
      <RuntimeJsonFile>$(RuntimeJsonFileDir)runtime.json</RuntimeJsonFile>
    </PropertyGroup>

    <MakeDir Condition="!Exists('$(ArtifactsPackagingDir)')" Directories="$(ArtifactsPackagingDir)" />
    <Delete Condition="Exists('$(RuntimeJsonFile)')" Files="$(RuntimeJsonFile)" />
    <WriteLinesToFile Lines="@(RuntimeJson)" File="$(RuntimeJsonFile)"/>
  </Target>
          
</Project>
